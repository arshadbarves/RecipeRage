using System.Collections.Generic;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace Core.Localization.Editor
{
    /// <summary>
    /// Utility to generate C# constants from Localization.csv to ensure type safety.
    /// </summary>
    public static class LocalizationGenerator
    {
        private const string CsvPath = "Assets/Resources/Data/Localization.csv";
        private const string OutputPath = "Assets/Scripts/Gameplay/UI/Localization/LocalizationKeys.g.cs";

        [MenuItem("Tools/Localization/Generate Keys")]
        public static void Generate()
        {
            string fullCsvPath = Path.Combine(Application.dataPath, "../../", CsvPath);
            // Since we are in Editor, we can use relative paths or Path.GetFullPath
            // Actually Application.dataPath is Assets/
            // "Assets/Resources/Data/Localization.csv" is perfect for absolute path if we combine with project root.
            
            string projectRoot = Path.GetDirectoryName(Application.dataPath);
            string absoluteCsvPath = Path.Combine(projectRoot, CsvPath);

            if (!File.Exists(absoluteCsvPath))
            {
                Debug.LogError($"[LocalizationGenerator] CSV not found at: {absoluteCsvPath}");
                return;
            }

            var keys = new List<string>(); // Use list to preserve order if possible
            var lines = File.ReadAllLines(absoluteCsvPath);

            // Skip header
            for (int i = 1; i < lines.Length; i++)
            {
                var line = lines[i].Trim();
                if (string.IsNullOrEmpty(line)) continue;

                var firstComma = line.IndexOf(',');
                if (firstComma == -1) continue;

                var key = line.Substring(0, firstComma).Trim();
                if (!string.IsNullOrEmpty(key))
                {
                    if (!keys.Contains(key)) keys.Add(key);
                }
            }

            GenerateCode(keys);
            AssetDatabase.Refresh();
            Debug.Log($"[LocalizationGenerator] Successfully generated {keys.Count} keys to {OutputPath}");
        }

        private static void GenerateCode(List<string> keys)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// This code was generated by a tool (LocalizationGenerator.cs)");
            sb.AppendLine("// Do not modify this file manually.");
            sb.AppendLine("");
            sb.AppendLine("namespace Gameplay.UI.Localization");
            sb.AppendLine("{");
            sb.AppendLine("    public static class LocKeys");
            sb.AppendLine("    {");

            foreach (var key in keys)
            {
                var constName = FormatConstName(key);
                sb.AppendLine($"        public const string {constName} = \"{key}\";");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            string projectRoot = Path.GetDirectoryName(Application.dataPath);
            string absoluteOutputPath = Path.Combine(projectRoot, OutputPath);

            var dir = Path.GetDirectoryName(absoluteOutputPath);
            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllText(absoluteOutputPath, sb.ToString());
        }

        private static string FormatConstName(string key)
        {
            if (string.IsNullOrEmpty(key)) return "InvalidKey";

            // Support keys like "settings_btn_back" -> "SettingsBtnBack"
            var parts = key.Replace('-', '_').Split('_');
            var result = new StringBuilder();
            foreach (var part in parts)
            {
                if (part.Length > 0)
                {
                    result.Append(char.ToUpper(part[0]));
                    if (part.Length > 1) result.Append(part.Substring(1));
                }
            }
            return result.ToString();
        }
    }
}
